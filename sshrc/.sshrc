#!/usr/bin/env bash
#### GENERAL
# use .vimrc form .sshrc.d
export VIMINIT="let \$MYVIMRC='$SSHHOME/.sshrc.d/.vimrc' | source \$MYVIMRC"
# only define LC_CTYPE if undefined
if [[ -z "$LC_CTYPE" && -z "$LC_ALL" ]]; then
  export LC_CTYPE=${LANG%%:*} # pick the first entry from LANG
fi
function bash_stats() {
  fc -l 1 | awk '{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl |  head -n20
}

# If set, Bash checks the window size after each command and, if necessary, updates the values of LINES and COLUMNS.
shopt -s checkwinsize

#### MOVE AROUND SYSTEM
shopt -s autocd
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias -- -='cd -'
alias 1='cd -'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'
alias 6='cd -6'
alias 7='cd -7'
alias 8='cd -8'
alias 9='cd -9'
function take() {
  mkdir -p $1
  cd $1
}
# If set, minor errors in the spelling of a directory component in a cd command will be corrected.
shopt -s cdspell
# Integrate with z
mkdir -p $SSHOME/z
export _Z_DATA=$SSHOME/z
. $SSHHOME/.sshrc.d/z.sh
man_z


#### HISTORY
# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth
# append to the history file, don't overwrite it
shopt -s histappend
## Command history configuration
if [ -z "$HISTFILE" ]; then
    HISTFILE=$HOME/.bash_history
fi
HISTSIZE=10000
SAVEHIST=10000
# If set, Bash attempts to save all lines of a multiple-line command
# in the same history entry. This allows easy re-editing of multi-line
# commands.
shopt -s cmdhist


#### COLORS
# System utils with colors
alias ls="ls --color=auto"
alias dir='dir --color=auto'
alias vdir='vdir --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac
# colored ls
export LSCOLORS='Gxfxcxdxdxegedabagacad'

## pager
if command less &>/dev/null; then
  export PAGER="less"
  export LESS="--RAW-CONTROL-CHARS"
  export LESS_TERMCAP_mb=$(tput bold; tput setaf 2) # green
  export LESS_TERMCAP_md=$(tput bold; tput setaf 6) # cyan
  export LESS_TERMCAP_me=$(tput sgr0)
  export LESS_TERMCAP_so=$(tput bold; tput setaf 3; tput setab 4) # yellow on blue
  export LESS_TERMCAP_se=$(tput rmso; tput sgr0)
  export LESS_TERMCAP_us=$(tput smul; tput bold; tput setaf 7) # white
  export LESS_TERMCAP_ue=$(tput rmul; tput sgr0)
  export LESS_TERMCAP_mr=$(tput rev)
  export LESS_TERMCAP_mh=$(tput dim)
  export LESS_TERMCAP_ZN=$(tput ssubm)
  export LESS_TERMCAP_ZV=$(tput rsubm)
  export LESS_TERMCAP_ZO=$(tput ssupm)
  export LESS_TERMCAP_ZW=$(tput rsupm)
  export GROFF_NO_SGR=1         # For Konsole and Gnome-terminal
fi


#### GREPPING
## more intelligent acking for ubuntu users
if which ack-grep &> /dev/null; then
  alias afind='ack-grep -il'
else
  alias afind='ack -il'
fi
# is x grep argument available?
grep_flag_available() {
    echo | grep $1 "" >/dev/null 2>&1
}

GREP_OPTIONS=""

# color grep results
if grep_flag_available --color=auto; then
    GREP_OPTIONS+=( " --color=auto" )
fi

# ignore VCS folders (if the necessary grep flags are available)
VCS_FOLDERS="{.bzr,CVS,.git,.hg,.svn}"

if grep_flag_available --exclude-dir=.cvs; then
    GREP_OPTIONS+=( " --exclude-dir=$VCS_FOLDERS" )
elif grep_flag_available --exclude=.cvs; then
    GREP_OPTIONS+=( " --exclude=$VCS_FOLDERS" )
fi

# export grep settings
alias grep="grep $GREP_OPTIONS"

# clean up
unset GREP_OPTIONS
unset VCS_FOLDERS
unset -f grep_flag_available


# ALIASES
# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias t="tree"
alias gcd="cd-gitroot"
alias g="git"



#-----------------------------------------------------------------------------
# Begin Prompt section
#-----------------------------------------------------------------------------
export GT_RESET="$(tput sgr0)"      # Reset all attributes
export GT_BRIGHT="$(tput bold)"     # Set "bright" attribute
export GT_DIM="$(tput dim)"         # Set "dim" attribute
export PALE_ROSE="$(tput setaf 173)"
export BRIGHT_BLUE="$(tput setaf 39)"
export PALE_BLUE="$(tput setaf 153)"
export BRIGHT_YELLOW="$(tput setaf 220)"
export PALE_GREEN="$(tput setaf 156)"
export SOFT_PINK="$(tput setaf 167)"
export BRIGHT_RED="$(tput setaf 196)"

# Stores the exit status of the last command for use by show_exit_status function.
if [[ ! $PROMPT_COMMAND =~ store_exit_status ]]; then
  export PROMPT_COMMAND="store_exit_status && ${PROMPT_COMMAND:-:}"
fi

store_exit_status() {
  LAST_EXIT_STATUS=$?
}

show_time() {
  echo "${PALE_BLUE}[$(date +%H:%M)]${GT_RESET}"
}

show_exit_status() {
  if [ "x${LAST_EXIT_STATUS}" != "x0" ]; then
    echo "${GT_BRIGHT}${SOFT_PINK}[${LAST_EXIT_STATUS}]${GT_RESET}"
  fi
}

prompt_color() {

if [[ -z "$SSH_CLIENT" && "${UID}" -ne "0" ]]; then
        echo "${GT_BRIGHT}${PALE_GREEN}"
    elif [ "${UID}" -eq "0" ]; then
        echo "${GT_BRIGHT}${BRIGHT_RED}"
    else
        echo "${GT_BRIGHT}${BRIGHT_YELLOW}"
fi
}

prompt_symbol() {
if [ "${UID}" -eq "0" ]; then
        printf "[root]⌘"
    else
        printf "⌘"
fi

}
#-----------------------------------------------------------------------------
# Prompts - defined colors below
#-----------------------------------------------------------------------------
set_prompts() {

# Define prompt based on whether I am local or connected via ssh

        PS1='$(show_time) $(prompt_color)'"\h${COLOR_NONE}:${BRIGHT_BLUE}\w${GT_RESET}"' $(show_exit_status)'"${GT_RESET}\n$(prompt_symbol) "

        PS2="${BRIGHT_BLUE}>${DEFAULT} "
        PS3=$PS2
        PS4="${BRIGHT_RED}+${DEFAULT} "

    # Special prompt for Debian: Include variable identifying the chroot you work in in the prompt
    # (copied from default Debian .bashrc file, never actually tested)
    if [ -z "$debian_chroot" ] && [ -r "/etc/debian_chroot" ]; then
        export debian_chroot=`cat /etc/debian_chroot`
        PS1="${debian_chroot:+($debian_chroot)}${PS1}"
    fi

    export PS1 PS2 PS3 PS4
}
set_prompts
unset -f set_prompts
#-----------------------------------------------------------------------------
# End Prompt section
#-----------------------------------------------------------------------------
