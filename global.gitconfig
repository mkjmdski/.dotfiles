#### STANDARD SETTINGS
[core]
	# Don't consider trailing space change as a cause for merge conflicts
	whitespace = -trailing-space
	# Use vim as default editor
	editor = vim
	# Use GUI editors
	# editor = code --wait
	# editor = subl -n -w
	# editor = atom --wait

#### COLORS DEFINITIONS
[color]
	ui = auto

[color "branch"]
	current = yellow reverse
	local = yellow
	remote = green

[color "diff"]
	meta = yellow bold
	frag = magenta bold
	old = red bold
	new = green bold

[color "status"]
	added = yellow
	changed = green
	untracked = cyan

#### COMMAND SETTINGS
[log]
	# Use abbrev SHAs whenever possible/relevant instead of full 40 chars
	abbrevCommit = true

[push]
	# When pushing, also push tags whose commit-ishs are now reachable upstream
	followTags = true
	autoSetupRemote = true

[tag]
	# Sort tags as version numbers whenever applicable, so 1.10.2 is AFTER 1.2.0.
	sort = version:refname

[pull]
	#always rebase and stash before pulling
	rebase = true

[status]
	# show branch and stash
	branch = true
	showStash = true

[rebase]
	autoStash = true
    instructionFormat = %s [%an]

[sequence]
    editor = interactive-rebase-tool

#### MERGETOOLS
# PyCharm
# [merge]
#     tool = pycharm
# [mergetool "pycharm"]
# 	cmd = /usr/local/bin/charm merge "$LOCAL" "$REMOTE" "$BASE" "$MERGED"
# VIM

[merge]
	tool = vimdiff
	conflictstyle = diff3

[mergetool "vimdiff"]
	prompt = false


#### DIFF TOOLS
[diff]
	renames = true
	tool = icdiff
#     tool = pycharm

[difftool]
	prompt = false

[difftool "icdiff"]
	cmd = icdiff --line-numbers $LOCAL $REMOTE

# [difftool "pycharm"]
# 	cmd = /usr/local/bin/charm diff "$LOCAL" "$REMOTE" && echo "Press enter to continue..." && read

#### ALIASES
[alias]
	p = "!f(){ git push || (git pull && git push) ; }; f"
	pu = "!f() { if ! git is-clean; then git st; git pull; git pop; else git pull; fi; }; f"
	hard = "!f() { git reset --hard origin/$(git current-branch) ; }; f"
	a = add --all
	m = commit --message
	cam = "!f(){ git add -A && git commit -m \"$@\" ; }; f"
	tcam = "!f(){ if git current-branch | grep -q ABP; then ticket=$(git current-branch | cut -d '-' -f 1-2); git cam 'feat('$ticket'): '\"$1\"; else git cam 'feat: '\"$1\"; fi ; }; f"
	amp = "!f(){ git cam \"$@\" ; git p ; }; f"
	tamp = "!f(){ git tcam \"$@\" ; git p ; }; f"
	map = amp
	mp = "!f(){ git commit -m \"$@\"; git p ; }; f"
	merge-me = "!f(){ b=$(git current-branch); git checkout ${1:-master}; git merge $b; }; f"
	s = status
	annotate-tag = "!f(){ tag=\"$(git describe --tags)\"; git delete-tag $tag; git tag -a $tag -m \"$(git show -s --format=%s)\"; git p ; }; f"
	st = stash save --include-untracked
	pop = stash pop
	push-u = "!f(){ git push -u ${1-origin} $(git current-branch) ; }; f"
	push-mr = "!f(){ git push -u ${1-origin} $(git current-branch) -o merge_request.create ; }; f"
	amend = commit --amend --no-edit
	force = push --force-with-lease
	log-line = log --pretty=format:\"%C(yellow)%h %ar %C(auto)%d %Creset %s, %Cblue%cn\" --graph --all
	uncommit = reset HEAD~
	unstage = reset HEAD
	current-branch = "rev-parse --abbrev-ref HEAD"
	list-changed-files = "show --name-only"
	# show changed dirs
	dirs = "!f(){ git diff --dirstat=files,0 | awk '{print $2}' | sort | uniq ; }; f"
	overwrite = !git a && git amend && git force
	merge-rebase = "!f() { actual=$(git current-branch) && git checkout $1 && git rebase $actual && git force && git checkout $actual && git merge $1 ; }; f"
	squash-branch = "!f() { git reset $(git merge-base ${2:-master} $(git current-branch)) ; git a ; git m ${1:-$(git log -1 --pretty=%B)} ; }; f"
	is-clean = "!f() { if ! git diff --exit-code --quiet || [[ ! -z "$(git ls-files --other --directory --exclude-standard)" ]]; then exit 1; fi ; }; f"
	message = "log -1 --pretty=%B"
	c = "checkout -"
	main = "!f() { git remote show origin | sed -n '/HEAD branch/s/.*: //p' ; }; f"
	cmain = "!f() { git checkout $(git main) ; }; f"
	rebase-main = "!f() { git cmain; git pull ; git c ; git rebase $(git main) ; }; f"
	list-conflicted = "diff --name-only --diff-filter=U --relative"
	open-conflicts = "!f() { code $(git list-conflicted) ; }; f"
	open-changed = "!f() { code $(git status -s | tail -n +2 | awk '{print $2}') ; }; f"
[filter "lfs"]
	clean = git-lfs clean -- %f
	smudge = git-lfs smudge -- %f
	process = git-lfs filter-process
	required = true
